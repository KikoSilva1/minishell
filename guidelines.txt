typedef enum e_token_type
{
	WORD,        // texto normal: comando, argumento, nome de arquivo
	PIPE,        // |
	REDIR_IN,    // <
	REDIR_OUT,   // >
	APPEND,      // >>
	HEREDOC      // <<
}	t_token_type;

typedef struct s_token
{
	char            *value;   // conteúdo do token ("cat", ">", etc.)
	t_token_type    type;     // tipo (WORD, PIPE, etc.)
	struct s_token  *next;    // próximo token
}	t_token;

//----------------------------------------------------------------TOKENIZER-----------------------------------------------------

read_input()
→ Lê a linha do utilizador com readline().
skip_spaces()
→ Avança pelos espaços até encontrar o próximo caractere útil.
is_operator()
→ Verifica se o caractere atual é |, <, >, ou parte de << / >>.
handle_operator()
→ Cria um token de operador (pipe, redir_in, redir_out, append, heredoc).
handle_word()
→ Lê uma palavra normal até encontrar espaço ou operador.
handle_quotes()
→ Trata texto entre ' ' ou " ", respeitando o tipo de aspa.
create_token()
→ Cria um novo token com o valor e o tipo identificados.
add_token_to_list()
→ Adiciona o token criado à lista ligada de tokens.
check_unclosed_quotes()
→ Verifica se há aspas não fechadas (erro de sintaxe).
tokenize()
→ Função principal: percorre a linha, chama as funções acima e devolve a lista de tokens

----------------------------------------------------------------------EXPANCAO DE VARIAVEIS-------------------------------------------

expand_variables()
→ Função principal: percorre todos os tokens e expande $VAR, $?, etc., quando permitido.
should_expand()
→ Verifica se o token pode ser expandido (não dentro de aspas simples, sim em aspas duplas ou fora delas).
find_variable_name()
→ Lê o nome da variável logo após o $.
get_env_value()
→ Procura o valor da variável no ambiente (envp ou lista interna).
replace_variable()
→ Substitui $VAR pelo valor correspondente no token.
expand_exit_status()
→ Substitui $? pelo valor do último código de saída.
handle_quotes_after_expansion()
→ Ajusta o token se as aspas influenciam o resultado final (ex: remover aspas se necessário).
expand_in_heredoc()
→ Só expande se o delimitador não estiver entre aspas.
update_token_value()
→ Atualiza o value do token com o texto expandido.
remove_empty_tokens()
→ Remove tokens que ficaram vazios após a expansão (ex: $VAR que não existia)
----------------------------------------------------------------------CONSTRUIR AST(ARVORE BINARIA)--------------------------------------------

Estrutura da Arvore Binaria:

typedef enum e_node_type {
    NODE_CMD,   // folha: comando simples
    NODE_PIPE,  // operador |
    NODE_AND,   // operador &&
    NODE_OR     // operador ||
} t_node_type;

typedef struct s_ast_node {
    t_node_type type;         // tipo do nó
    struct s_ast_node *left;  // filho esquerdo
    struct s_ast_node *right; // filho direito
    t_simplecmd *cmd;         // válido se tipo == NODE_CMD
} t_ast_node;

-----------------------------------------------------------------------------------------
Estrutura do simple command:

typedef enum e_operator {
    OP_NONE,   // sem operador seguinte
    OP_PIPE,   // |
    OP_AND,    // &&
    OP_OR      // ||
} t_operator;

typedef struct s_simplecmd {
    char **argv;           // array de argumentos (terminado em NULL)
    t_redir *redirs;       // lista de redireções
    t_operator next_op;    // operador que liga ao próximo comando
    struct s_simplecmd *next; // próxima comando na lista, útil antes da AST
} t_simplecmd;
--------------------------------------------------------------------------------------

Estrutura da redirecao:

typedef enum e_redir_type {
    REDIR_IN,     // <
    REDIR_OUT,    // >
    REDIR_APPEND, // >>
    HEREDOC       // <<
} t_redir_type;

typedef struct s_redir {
    t_redir_type type;   // tipo da redireção
    char *filename;      // ficheiro associado
    struct s_redir *next; // próxima redireção no mesmo comando
} t_redir;

Um comando simples no shell pode ter mais de uma redireção, por exemplo:
command < input.txt > output.txt >> log.txt dai o s_redir *next.

1 - Agrupar comandos - cirar a linked list de comandos:  CMD1 -> CMD2 -> CMD3

	Percorre a lista de tokens
	Para cada token:
	Se for WORD:
	➜ adiciona a argv
	Se for uma redireção (>, >>, <, <<):
	➜ lê o próximo token (o ficheiro)
	➜ guarda num t_redir { type, filename }
	➜ adiciona à lista de redirs

	Se for um operador (|, ||, &&):
	➜ marca esse operador como next_op do comando atual
	➜ termina o comando
	➜ começa um novo comando a seguir

	exemplo para visualizar : [echo] [hi] [|] [grep] [h] [&&] [echo] [ok] [||] [echo] [fail]

2 - Construir a AST:

	Percorre a lista de comandos simples do início ao fim.
	Cria um nó folha (NODE_CMD) para cada comando.
	Quando encontra um operador (next_op):
	Cria um nó interno (NODE_PIPE, NODE_AND, NODE_OR)
	Define left e right:
	left → comando (ou subárvore) à esquerda
	right → comando (ou subárvore) à direita


Lista de comandos:
CMD1(next_op=PIPE) -> CMD2(next_op=AND) -> CMD3(next_op=NONE)

AST resultante:

       AND
      /   \
   PIPE   CMD3
   /   \
CMD1   CMD2


